// expansion at /usr/include/dlang/dmd/std/format/internal/write.d(1993)
(in ref int a) => a

// expansion at compoints/backgroundscroll.d(11)
InitWindow(windowx, windowy, "Hello, Raylib-D!");
SetWindowPosition(1800,0);
SetTargetFPS(60);
import tile;
mixin setupdraw!("tile");
import ship;
mixin setupdraw!("ship");
import ascii;
mixin setupdraw!("ascii");
//TODO, recreate the overload hack in survoir/drawing.mix
template draw_(){
	void drawtilerow(tilerow a,int y){
		foreach(i,e;a){
			drawtile(e,(i*32).to!int,y,2);
		}
	}
	void drawasciirow(string a,int y){
		foreach(i,e;a){
			drawascii(e,(i*48).to!int,y,1);
		}
	}
	void drawbackground(int size,T)(T bg,int offset){
		import std.range;
		foreach(i,ref row;bg[].enumerate){
			import consants;
			drawtilerow(row,playfieldy-cast(int)(i)*size+offset);
	}}
	void drawwords(int size,T)(T bg,int offset){
		import std.range;
		foreach(i,ref row;bg[].enumerate){
			import consants;
			drawasciirow(row,playfieldy-cast(int)(i)*size+offset);
	}}
	void draw(background bg){
		drawbackground!(32)(bg.tiles,-bg.offset);
		drawwords!(48)(bg.words,0);
	}
	void draw(player a){
		drawship(0,a.x,a.y,2);
	}
	void draw(bullets bs){
		foreach(b;bs){
			drawtile(b.which,b.x,b.y);
		}
	}
	void draw(enemybullets bs){
		foreach(b;bs){
			drawtile(b.which,b.x,b.y);
		}
	}
	void draw(bigships ss){
		foreach(s;ss){
			drawship(s.type+1,cast(int)s.pos.x,cast(int)s.pos.y,2);
	}}
	void draw(midships ss){
		foreach(s;ss){
			drawship(s.type+4,cast(int)s.pos.x,cast(int)s.pos.y,1.5);
	}}
	void draw(smlships ss){
		foreach(s;ss){
			drawship(s.type+16,cast(int)s.pos.x,cast(int)s.pos.y,1);
	}}
}
//void drawenemys(enemyships es){
//	foreach(e;es){
//		drawship(e.type,e.x,e.y,e.type<4?2:1);}
//}

auto draw(T...)(T args){
	draw_!().draw(args);
}

// expansion at ./source/tile.d(38)
void drawtile(T...)(T args){draw(args);}

// expansion at ./source/ship.d(37)
void drawship(T...)(T args){draw(args);}

// expansion at ./source/ascii.d(38)
void drawascii(T...)(T args){draw(args);}

// expansion at /usr/include/dlang/dmd/std/functional.d(448)
cast(T)a < cast(T) b

// expansion at /usr/include/dlang/dmd/std/internal/memory.d(40)
onOutOfMemoryError();

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at /usr/include/dlang/dmd/std/functional.d(218)
alias a = __a ;

// expansion at /usr/include/dlang/dmd/std/functional.d(219)
alias b = __b ;

// expansion at /usr/include/dlang/dmd/std/functional.d(220)
a == b

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at /usr/include/dlang/dmd/std/typecons.d(445)
enum int index = 0;

// expansion at /usr/include/dlang/dmd/std/typecons.d(445)
enum int value = 0;

// expansion at /usr/include/dlang/dmd/std/typecons.d(624)
alias _0LU = Identity!(field[0LU]);alias index = _0LU;alias _1LU = Identity!(field[1LU]);alias value = _1LU;

// expansion at /usr/include/dlang/dmd/std/typecons.d(624)
alias _0LU = Identity!(field[0LU]);alias _1LU = Identity!(field[1LU]);

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs == rhs

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs == rhs

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs == rhs

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs == rhs

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs == rhs

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs == rhs

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs == rhs

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs == rhs

// expansion at /usr/include/dlang/dmd/std/typecons.d(445)
enum int index = 0;

// expansion at /usr/include/dlang/dmd/std/typecons.d(445)
enum int value = 0;

// expansion at /usr/include/dlang/dmd/std/typecons.d(624)
alias _0LU = Identity!(field[0LU]);alias index = _0LU;alias _1LU = Identity!(field[1LU]);alias value = _1LU;

// expansion at /usr/include/dlang/dmd/std/typecons.d(624)
alias _0LU = Identity!(field[0LU]);alias _1LU = Identity!(field[1LU]);

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs == rhs

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs == rhs

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs == rhs

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs == rhs

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs == rhs

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs == rhs

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs == rhs

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs == rhs

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs == rhs

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs == rhs

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs < rhs

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs < rhs

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs == rhs

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs == rhs

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs < rhs

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs < rhs

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs == rhs

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs == rhs

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs < rhs

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs < rhs

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs == rhs

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs == rhs

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs < rhs

// expansion at /usr/include/dlang/dmd/std/typecons.d(517)
lhs < rhs

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at /usr/include/dlang/dmd/std/functional.d(448)
cast(T)a < cast(T) b

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at ./raylib/raymathext.d(82)
T(0.)

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at ./raylib/raymathext.d(88)
T(1.)

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at ./raylib/raymathext.d(82)
T(0.,0.,0.)

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at ./raylib/raymathext.d(88)
T(1.,1.,1.)

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at ./raylib/raymathext.d(82)
T(0.,0.,0.,0.)

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at ./raylib/raymathext.d(88)
T(1.,1.,1.,1.)

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at ./raylib/raymathext.d(172)
sqrt(v.x*v.x+v.y*v.y)

// expansion at /usr/include/dlang/dmd/std/functional.d(218)
alias a = __a ;

// expansion at /usr/include/dlang/dmd/std/functional.d(219)
alias b = __b ;

// expansion at /usr/include/dlang/dmd/std/functional.d(220)
a == b

// expansion at /usr/include/dlang/dmd/std/functional.d(218)
alias a = __a ;

// expansion at /usr/include/dlang/dmd/std/functional.d(219)
alias b = __b ;

// expansion at /usr/include/dlang/dmd/std/functional.d(220)
a == b

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at ./raylib/raymathext.d(148)
T(x/rhs,y/rhs)

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at ./raylib/raymathext.d(189)
lhs.x*rhs.x+lhs.y*rhs.y

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at ./raylib/raymathext.d(148)
T(x*rhs,y*rhs)

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at ./raylib/raymathext.d(189)
lhs.x*rhs.x+lhs.y*rhs.y+lhs.z*rhs.z

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at ./raylib/raymathext.d(172)
sqrt(v.a*v.a+v.xy*v.xy+v.yz*v.yz+v.zx*v.zx)

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at ./raylib/raymathext.d(148)
T(a/rhs,xy/rhs,yz/rhs,zx/rhs)

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at ./raylib/raymathext.d(154)
T(lhs*xy,lhs*yz,lhs*zx)

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at ./raylib/raymathext.d(94)
T(-xy,-yz,-zx)

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at ./raylib/raymathext.d(82)
T(0.,0.)

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at ./raylib/raymathext.d(88)
T(1.,1.)

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at ./raylib/raymathext.d(82)
T(0.,0.,0.)

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at ./raylib/raymathext.d(88)
T(1.,1.,1.)

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at ./raylib/raymathext.d(82)
T(0.,0.,0.,0.)

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at ./raylib/raymathext.d(88)
T(1.,1.,1.,1.)

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at /usr/include/dlang/dmd/std/functional.d(218)
alias a = __a ;

// expansion at /usr/include/dlang/dmd/std/functional.d(219)
alias b = __b ;

// expansion at /usr/include/dlang/dmd/std/functional.d(220)
a == b

// expansion at ./raylib/raymathext.d(160)
x*= rhs;

// expansion at ./raylib/raymathext.d(160)
y*= rhs;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at ./raylib/raymathext.d(134)
T(x+rhs.x,y+rhs.y)

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at ./raylib/raymathext.d(134)
T(x-rhs.x,y-rhs.y)

// expansion at ./raylib/raymathext.d(140)
x+= rhs.x;

// expansion at ./raylib/raymathext.d(140)
y+= rhs.y;

// expansion at 
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at /usr/include/dlang/dmd/core/internal/atomic.d(153)

                    asm pure nothrow @nogc @trusted
                    {
                        naked;
                        mov EDX, 0;
                        mov EAX, 0;
                        lock; cmpxchg [RDI], EDX;
                        ret;
                    }
                

// expansion at /usr/include/dlang/dmd/core/atomic.d(557)
*cast(T*)&val+=mod

// expansion at /usr/include/dlang/dmd/core/internal/atomic.d(271)

                asm pure nothrow @nogc @trusted
                {
                    naked;
                    lock; xadd[RSI], EDI;
                    mov EAX, EDI;
                    ret;
                }
            

